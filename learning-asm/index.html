<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>简单的汇编学习笔记与总结 - リン屋</title>

  
    <meta name="description" content="根据CSAPP第三章内容与课堂讲义总结，默认是x86-64系统，C语言。这里讨论的都是整数。因为我比较菜，写的比较垃圾，争取自己复习的时候可以看懂。">
<meta property="og:type" content="article">
<meta property="og:title" content="简单的汇编学习笔记与总结">
<meta property="og:url" content="https://github.com/RinChanNOWWW/learning-asm/">
<meta property="og:site_name" content="リン屋">
<meta property="og:description" content="根据CSAPP第三章内容与课堂讲义总结，默认是x86-64系统，C语言。这里讨论的都是整数。因为我比较菜，写的比较垃圾，争取自己复习的时候可以看懂。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/blog/images/learning-asm/64bit-register.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/blog/images/learning-asm/32bit-register.png">
<meta property="article:published_time" content="2018-11-08T12:18:25.000Z">
<meta property="article:modified_time" content="2018-11-08T12:18:25.000Z">
<meta property="article:author" content="RinChanNOW">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/blog/images/learning-asm/64bit-register.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/profile/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">リン屋</div><div class="sub cap">RinChanNOW's blog</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">简单的汇编学习笔记与总结</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">整数寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-text">操作数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-text">引用内存的多种形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-text">基本的汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-text">数据传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="toc-text">压入和弹出栈数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="toc-text">加载有效地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="toc-text">其他算术和逻辑操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">移位操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="toc-text">特殊算术操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%B9%98%E9%99%A4%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-text">整数乘除指令总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">控制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">其他操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6"><span class="toc-text">控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%AF%B9%E6%9D%A1%E4%BB%B6%E7%A0%81%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">定点算术运算和逻辑运算对条件码的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%92%8C%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">比较和控制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">设置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">跳转指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"><span class="toc-text">未完待续</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/blog/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div id="post-meta">发布于&nbsp;<time datetime="2018-11-08T12:18:25.000Z">2018-11-08</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>简单的汇编学习笔记与总结</span></h1>
<p><font color=#DC143C><strong>根据CSAPP第三章内容与课堂讲义总结，默认是x86-64系统，C语言。这里讨论的都是整数。</strong></font><br><font color=#DC143C><strong>因为我比较菜，写的比较垃圾，争取自己复习的时候可以看懂。</strong></font></p>
<span id="more"></span>

<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><table>
<thead>
<tr>
<th align="center">C声明</th>
<th align="center">Intel数据类型</th>
<th align="center">汇编代码后缀</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">字节</td>
<td align="center">b</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">字</td>
<td align="center">w</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">双字</td>
<td align="center">l</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char*</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度</td>
<td align="center">s</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度</td>
<td align="center">l</td>
<td align="center">8</td>
</tr>
</tbody></table>
<hr>
<h2 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/blog/images/learning-asm/64bit-register.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/RinChanNOWWW/jsdelivrp-cdn@master/blog/images/learning-asm/32bit-register.png"></p>
<hr>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><ol>
<li>立即数：<br>直接表示常数值。例子：<code>$577</code>, <code>0x1F</code>。</li>
</ol>
</li>
<li><ol start="2">
<li>寄存器：<br>某个寄存器里的内容。例子: <code>%rax</code>, <code>%ecx</code>。</li>
</ol>
</li>
<li><ol start="3">
<li>内存引用：<br>根据计算出来的地址访问内存中的位置。例子：<code>(%rax)</code>, <code>(0x100)</code>。</li>
</ol>
</li>
</ul>
<h3 id="引用内存的多种形式"><a href="#引用内存的多种形式" class="headerlink" title="引用内存的多种形式"></a>引用内存的多种形式</h3><ul>
<li><ol>
<li>(R) : Mem[Reg[R]] : 直接访问。如：<code>(%rax)</code>。</li>
</ol>
</li>
<li><ol start="2">
<li>D(R) : Mem[Reg[R] + D] : 访问原始地址加上偏移量后的地址。如：<code>8(%rbp)</code>， 访问的是 <code>%rbp + 8</code> 地址的值。</li>
</ol>
</li>
<li><ol start="3">
<li>D(Rb, Ri, s) : Mem(Reg[Rb] + Reg[Ri] * s) : 比例变址寻址。如：<code>4(%rax, %rdx, 4)</code>，访问的是 <code>%rax + %rdx  * 4 + 4</code>地址的值。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="基本的汇编指令"><a href="#基本的汇编指令" class="headerlink" title="基本的汇编指令"></a>基本的汇编指令</h2><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><font color=#DC143C>MOV类：</font>MOV Src, Dst ：把Src上面的数据传送到Dst上</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movb</td>
<td align="center">传送字节</td>
</tr>
<tr>
<td align="center">movw</td>
<td align="center">传送字</td>
</tr>
<tr>
<td align="center">movl</td>
<td align="center">传送双字</td>
</tr>
<tr>
<td align="center">movq</td>
<td align="center">传送四字</td>
</tr>
<tr>
<td align="center">movabsq</td>
<td align="center">传送绝对四字</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值扩展到64位再放到目的位置，</li>
</ul>
<p><strong>而movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</strong></p>
<ul>
<li>大多数情况中，MOV指令只会更新目的操作数指定的寄存器字节或内存位置，高位不变。<strong>唯一的例外是movl指令以寄存器作为目的时，它会把寄存器的高位4字节设置为0</strong></li>
<li>传输<strong>不能</strong>从内存到内存</li>
</ul>
<p><font color=#DC143C>MOVZ和MOVS类：</font>MOVZ/MOVS Src, Dst ：将较小的源值复制到较大的目的时使用，分别是零扩展（剩余填充0）和符号扩展（剩余填充符号位）。</p>
<p>零扩展：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movzbw</td>
<td align="center">将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td align="center">mozbl</td>
<td align="center">将做了零扩展的字节传送到双字</td>
</tr>
<tr>
<td align="center">movzwl</td>
<td align="center">将做了零扩展的字传送到双字</td>
</tr>
<tr>
<td align="center">movzbq</td>
<td align="center">将做了零扩展的字节传送到四字</td>
</tr>
<tr>
<td align="center">movzwq</td>
<td align="center">将做了零扩展的s字传送绝对四字</td>
</tr>
</tbody></table>
<p>符号扩展：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movsbw</td>
<td align="center">将做了符号扩展的字节传送到字</td>
</tr>
<tr>
<td align="center">mosbl</td>
<td align="center">将做了符号扩展的字节传送到双字</td>
</tr>
<tr>
<td align="center">movswl</td>
<td align="center">将做了符号扩展的字传送到双字</td>
</tr>
<tr>
<td align="center">movsbq</td>
<td align="center">将做了符号扩展的字节传送到四字</td>
</tr>
<tr>
<td align="center">movswq</td>
<td align="center">将做了符号扩展的字传送绝对四字</td>
</tr>
<tr>
<td align="center">movslq</td>
<td align="center">将做了符号扩展的双字传送到四字</td>
</tr>
<tr>
<td align="center">cltq</td>
<td align="center">把%eax符号扩展到%rax</td>
</tr>
</tbody></table>
<p><strong>注意：cltq指令只能作用于寄存器%eax和%rax</strong><br>数据传输的例子：</p>
<ol>
<li>第一个例子</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movabsq <span class="number">$0</span>x0011223344556677, %rax   # %rax = <span class="number">0x0011223344556677</span></span><br><span class="line">movb    $-<span class="number">1</span>, %al                    # %rax = <span class="number">0x00112233445566FF</span></span><br><span class="line">movw    $-<span class="number">1</span>, %ax                    # %rax = <span class="number">0x001122334455FFFF</span></span><br><span class="line">movl    $-<span class="number">1</span>, %eax                   # %rax = <span class="number">0x00000000FFFFFFFF</span></span><br><span class="line"><span class="keyword">movq</span>    $-<span class="number">1</span>, %rax                   # %rax = <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<p>2.第二个例子</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movabsq <span class="number">$0</span>x0011223344556677, %rax   # %rax = <span class="number">0x0011223344556677</span></span><br><span class="line">movb    <span class="number">$0</span>xAA, %dl                  # %dl  = <span class="number">0xAA</span></span><br><span class="line">movb %dl, %al                       # %rax = <span class="number">0x00112233445566AA</span></span><br><span class="line">movsbq %dl, %rax                    # %rax = <span class="number">0xFFFFFFFFFFFFFFAA</span></span><br><span class="line">movzbq %dl, %rax                    # %rax = <span class="number">0x00000000000000AA</span></span><br></pre></td></tr></table></figure>

<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><ul>
<li>push src：把数据压入栈中</li>
<li>pop dst：抽出栈顶数据</li>
</ul>
<p><strong>注意：</strong> 以上操作是通过寄存器%rsp中所存地址指向栈顶。抽出栈顶数据后，原来的数据保持在原来的内存位置中，直到被覆盖。<br>这里的相关内容还没细讲，以后再补吧。</p>
<h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p><font color=#DC143C>leaq指令：</font> leaq Src, Dst：直接将有效地址（即：把<font color=#FF8C00>括号内的值</font>，不读入对应内存的数据）写入到目的。<br><strong>leaq可以简洁地描述普通的算术操作</strong><br>例如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq <span class="number">7</span>(%rdi, %rsi, <span class="number">4</span>), %rax         # 设%rdi总存数据x，%rsi中存数据y，则这条指令是将 x+4y+<span class="number">7</span> 存入%rax中</span><br></pre></td></tr></table></figure>
<h3 id="其他算术和逻辑操作"><a href="#其他算术和逻辑操作" class="headerlink" title="其他算术和逻辑操作"></a>其他算术和逻辑操作</h3><p>这里先简单的给出这些操作：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>inc D</td>
<td>D = D + 1</td>
</tr>
<tr>
<td>dec D</td>
<td>D = D - 1</td>
</tr>
<tr>
<td>neg D</td>
<td>D = -D</td>
</tr>
<tr>
<td>not D</td>
<td>D = ~D</td>
</tr>
<tr>
<td>add S,D</td>
<td>D = D + S</td>
</tr>
<tr>
<td>sub S,D</td>
<td>D = D - S</td>
</tr>
<tr>
<td>imul S,D</td>
<td>D = D * S</td>
</tr>
<tr>
<td>xor S,D</td>
<td>D = D ^ S</td>
</tr>
<tr>
<td>or S,D</td>
<td>D = D &#124; S</td>
</tr>
<tr>
<td>and S,D</td>
<td>D = D &amp; S</td>
</tr>
<tr>
<td>sal k,D</td>
<td>D = D &lt;&lt; k</td>
</tr>
<tr>
<td>shl k,D</td>
<td>D = D &lt;&lt; k</td>
</tr>
<tr>
<td>sar k,D</td>
<td>D = D &gt;&gt;<sub>算术</sub>k</td>
</tr>
<tr>
<td>shr k,D</td>
<td>D = D &gt;&gt;<sub>逻辑</sub>k</td>
</tr>
</tbody></table>
<p>(注意到sal和shl是一样的，因为左移不会涉及符号位)</p>
<h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><p>移位操作对w位长的数据值进行操作，移位量是有%cl寄存器的低m位决定的，这里2<sup>m</sup>=w，剩余高位会被忽略。<br><strong>所以，例如当寄存器%cl是十六进制值为0xFF(11111111)时，指令salb会移7位(111，二进制3位)，salw会移15位(1111，二进制4位)，sall会移31位(11111，二进制5位)，salq会移63位(111111，二进制5位)。</strong> 这些位数也是对应指令能移动的最高位数。</p>
<p>这里来举个例子：一个32位的int数1，移动n=34位，计算1&lt;&lt;n，因为(34)<sub>10</sub>=(100010)<sub>2</sub> 取前五位00010，即2。所以1&lt;&lt;34等价于1&lt;&lt;2=4。其实就是让n mod 32(2<sup>m</sup>)。</p>
<p>所以习题3.60中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salq %cl, %rdx          # %ecx中的值为n，%rdx中的值是mask</span><br></pre></td></tr></table></figure>
<p>所以这条语句的作用是 <code>mask = mask &lt;&lt; n</code>，并不用截取%rcx的前八位<del>(n &amp; 0xFF)</del>，直接移动n为即可，因为salq最多移63位(11111)，n太大了也会被截成64以下（只取n二进制下的前6位）。</p>
<h4 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h4><ul>
<li>1.一个操作数<br>从上面的表我们可以看到，乘（mul和imul）和除（div和idiv）都是二元操作。这样的操作是在同位数数据采用的，比如：如果你用<br><code>imulq S,D</code>指令，则代表你计算的内容是一个64位数乘一个64位数并得到一个64位数。我们在前面的学习中便知道，w位数乘w位数会先得到一个2w位数，然后再截取前w位得到最后的结果。但如果你想得到就是那个2w位数，以w=64位例，计算机会将其处理未这样的汇编指令：<code>imulq S</code>。这条指令的效果是：R[%rdx]:R[%rax]&lt;–S/<em>R[%rax]，即把S中的数与%rax中的数做补码乘法后，*<em>将乘积的高64位存在%rdx中，低64位存在%rax中。</em></em> 当操作为无符号操作<code>mulq S</code>时同理。<br>这里有一个两个无符号64位数乘法得到无符号128位数的例子：<br>C语言代码为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store_uprod</span><span class="params">(<span class="keyword">uint128_t</span> *dest, <span class="keyword">uint64_t</span> x, <span class="keyword">uint64_t</span> y)</span></span>&#123;</span><br><span class="line">    *dest = x * (<span class="keyword">uint128_t</span>)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">store_uprod:</span></span><br><span class="line">    <span class="keyword">movq</span> %rsi, %rax                 </span><br><span class="line">    mulq %rdx</span><br><span class="line">    <span class="keyword">movq</span> %rax, (%rdi)</span><br><span class="line">    <span class="keyword">movq</span> %rdx, <span class="number">8</span>(%rdi)              # 小端机器</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>以64位为例，对于除法<code>idivl S</code>，他会把R[%rdx]:R[%rax]作为<strong>被除数</strong>（128位），S为除数，将结果的商存在%rax中，余存在%rdx中。如果被除数是64位，则%rdx中全为0（无符号位）或全为%rax的符号位（有符号运算），这两个操作可以用<code>cqto</code>（R[%rdx]:R[%rax]&lt;–R[%rax]完成。</p>
<p>对于64位以下的操作mulb / mulw / mull，一元乘除操作也是同理，<strong>另一个源操作数会隐含在R[%al] / R[%ax] / R[%eax]中，结果存在R[%ax] / R[%dx]:R[%ax] / R[%edx]:R[%eax]中</strong>，除法同理。<br>还需要注意一点的是有符号乘法，若要取2w位应该采用“布斯乘法”，也就是习题2.75让我们推导的计算两个w位补码运算结果的高w位（一共2w位）的方法：(x, y表示有符号数，x’,y’表示与其二进制表示相同的无符号数)</p>
<blockquote>
<p> (x’ * y’)<sub>高w位</sub> = (x * y)<sub>高w位</sub> + x * y的符号位 + y * x的符号位</p>
</blockquote>
<p>此公式的推导思路源于教材公式2.18。<br>例子：<br>无符号数0xB4 (180) 乘 无符号数0x11 (17) 结果为0xBF4 (3060)。<br>有符号数0xB4(-76) 乘 有符号数0x11 (17) 结果为0xFAF4 (-1292) ，并非<del>(0xBF4)</del>。(0xB=(0xFA+0x11) mod 64)</p>
<ul>
<li>2.三个操作数<br>指令： MUL Imm, Src, Reg<br>功能：将Src和立即数Imm相乘，结果存在Reg中。<br>例子：R[%eax] = 0xB4, R[%ebx] = 0x11, M[0xF8] = 0xA0，执行指令<code>imull $-16, (%eax, %ebx, 4), %eax</code>的效果：<br>R[%eax]&lt;– (-16) x M[R[%eax] + R[%ebx] x 4] = (-16) x M[0xB4 + 0x11 &lt;&lt; 2] = (-16) x M[0xF8] = (-16) x 0xA0 = 0xFFFFFF60 &lt;&lt; 4（做一个补码操作去除负号）= 0xFFFFF600 = -2560</li>
</ul>
<h4 id="整数乘除指令总结"><a href="#整数乘除指令总结" class="headerlink" title="整数乘除指令总结"></a>整数乘除指令总结</h4><ul>
<li>乘法<ul>
<li>一个操作数<br>若给出一个操作数Src，则另一个源操作数隐含在R[%al] / R[%ax] / R[%eax]中，将Src和前述寄存器（累加器accumulate）中内容相乘，结果存放在R[%ax]（16位）/ R[%dx]:R[%ax]（32位）/ R[%edx]:R[%eax]（64位）中。</li>
<li>两个操作数<br>MUL Src, Dst : Dst&lt;–Dst MUL Src</li>
<li>三个操作数<br>MUL Imm, Src, Reg : Reg&lt;–Imm MUL Src</li>
</ul>
</li>
<li>除法<ul>
<li>除数为8位，则16位被除数在R[%ax]中，商送回R[%al]，余数在R[%ah]</li>
<li>除数为16位，则32位被除数在R[%dx]:R[%ax]中，商送回R[%ax]，余数在R[%dx]</li>
<li>除数为32位，则64位被除数在R[%edx]:R[%eax]中，商送回R[%eax]，余数在R[%edx] </li>
<li>除数为64位，则128位被除数在R[%rdx]:R[%rax]中，商送回R[%rax]，余数在R[%rdx]</li>
</ul>
</li>
</ul>
<h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p>在下面介绍</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>输入输出指令(IN, OUT)和标志传送指令(PUSHF, POPF)等还没细讲，以后再补。</p>
<hr>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>的条件码寄存器，他们描述了<strong>最近</strong>的算术或逻辑操作的属性。可以检测这些寄存器来执行条<strong>条件分支指令</strong>。<br>最常用的条件码有：</p>
<ul>
<li><strong>CF</strong>：进位标志。最近的操作使最高位产生了进位（加分有进位（carry），减法有借位（borrow））。可以用来检查<strong>无符号</strong>操作的溢出。</li>
<li><strong>ZF</strong>：零标志。最近的操作得出结果为0。（所有位上数字都是0）</li>
<li><strong>SF</strong>：符号标志。最近的操作得到的结果为负数。</li>
<li><strong>OF</strong>：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。(如y……+y……=z……，或y…….-z……=z…… 「其中z=~y」等)</li>
</ul>
<h3 id="定点算术运算和逻辑运算对条件码的影响"><a href="#定点算术运算和逻辑运算对条件码的影响" class="headerlink" title="定点算术运算和逻辑运算对条件码的影响"></a>定点算术运算和逻辑运算对条件码的影响</h3><ul>
<li>ADD：影响OF, ZF, SF, CF。</li>
<li>SUB：影响OF, ZF, SF, CF。有借位，即减数&gt;被减数，则CF=1。两个数符号相反但结果符号与减数相同，则OF=1</li>
<li>INC：影响OF, ZF, SF。<strong>注意：不会影响CF</strong>，也就是说不会产生进位信息</li>
<li>DEC：影响OF, ZF, SF。<strong>注意：同INC</strong></li>
<li>NEG：影响OF, ZF, SF,  CF。相当于用0减操作数或者取反+1，OF变化同减法（所以只有当操作数为100…0时，OF才会变为1）</li>
<li>CMP：影响OF, ZF, SF, CF。</li>
<li>MUL：只影响OF, CF。乘积高一半为0，则CF=OF=0，否则是1。</li>
<li>IMUL：只影响OF, CF。乘积高一半为低一半的符号扩展，则CF=OF=0，否则是1。</li>
<li>DIV, IDIV：不影响上述条件码。</li>
<li>AND, OR, XOR, TEST：<strong>都会使OF和CF变为0</strong>，ZF和SF根据结果设置。</li>
<li><strong>NOT：不影响标志</strong></li>
<li>SHL, SHR, SAL, SAR, ROL, ROR：CF=移入的数值，ZF和SF根据结果设置，如果最高位变化，则OF=1，否则为0。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://abcdxyzk.github.io/blog/2012/12/20/assembly-cmd-flags/">参考链接</a></p>
<p>例子：R[%ax]=0xFFFA, R[%bx]=0xFFF0，执行指令（Intel格式）<code>add ax bx</code>：<br>R[%ax]&lt;–R[%ax] + R[%bx] = 0xFFFA + 0xFFF0 = 0xFFEA, R[%bx]中内容不变，CF = 1, OF = 0, ZF = 0, SF = 1。<br>对于上述例子，<strong>若是无符号整数运算，则CF=1说明结果溢出。若是有符号整数运算，OF=0说明结果没有溢出。</strong></p>
<h3 id="比较和控制指令"><a href="#比较和控制指令" class="headerlink" title="比较和控制指令"></a>比较和控制指令</h3><p><strong>这两种指令不修改任何寄存器的值，只设置条件码</strong></p>
<ul>
<li><ol>
<li>CMP (cmpb, cmpw, cmpl, cmpq)<br>CMP S1, S2：就是计算<strong>S2 - S1</strong>，以设置条件码得以看出比较的结果。</li>
</ol>
<ul>
<li>CF = 1: 发生了进位或借位（这里做减法一般是借位，借位了就表明S2 &lt; S1）</li>
<li>ZF = 1: S1 = S2</li>
<li>SF = 1: S2 - S1 &lt; 0（补码运算意义上的）</li>
<li>OF = 1: (a &gt; 0 &amp;&amp; b &lt; 0 &amp;&amp; (a - b) &lt; 0) || (a &lt; 0 &amp;&amp; b &gt; 0 &amp;&amp; (a - b) &gt; 0)</li>
</ul>
</li>
<li><ol start="2">
<li>TEST (testb, testw, testl, testq)<br>TEST S1, S2：就是计算<strong>S1 &amp; S2</strong>，以设置条件码。</li>
</ol>
<ul>
<li>ZF = 1: S1 &amp; S2 = 0</li>
<li>SF = 1: S1 &amp; S2 &lt; 0（补码运算意义上的）<br>经常使用这个指令测试一个数是不是负数：<code>testq %rax, %rax</code></li>
</ul>
</li>
</ul>
<h3 id="设置指令"><a href="#设置指令" class="headerlink" title="设置指令"></a>设置指令</h3><p>SET类的指令可以将一个字节的值设置为条件码的某种组合，这种指令的目的操作数是<strong>低位单字节寄存器之一或一个字节的内存位置</strong>（如%al），一般是配合比较和测试指令使用，下面列出常用的SET类指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>效果</th>
<th>设置条件</th>
</tr>
</thead>
<tbody><tr>
<td>sete D</td>
<td>setz</td>
<td>D &lt;– ZF</td>
<td>相等/零</td>
</tr>
<tr>
<td>setne D</td>
<td>setnz</td>
<td>D &lt;– ~ZF</td>
<td>不等/非零</td>
</tr>
<tr>
<td>sets D</td>
<td></td>
<td>D &lt;– SF</td>
<td>负数</td>
</tr>
<tr>
<td>setns D</td>
<td></td>
<td>D &lt;– ~SF</td>
<td>非负数</td>
</tr>
<tr>
<td>setg D</td>
<td>setnle</td>
<td>D &lt;– ~(SF ^ OF) &amp; ~ZF</td>
<td>有符号&gt; (greater)</td>
</tr>
<tr>
<td>setge D</td>
<td>setnl</td>
<td>D &lt;– ~(SF ^ OF)</td>
<td>有符号 &gt;=</td>
</tr>
<tr>
<td>setl D</td>
<td>setnge</td>
<td>D &lt;– SF ^ OF</td>
<td>有符号&lt;</td>
</tr>
<tr>
<td>setle D</td>
<td>setng</td>
<td>D &lt;– (SF ^ OF) &#124; ZF</td>
<td>有符号&lt;=</td>
</tr>
<tr>
<td>seta D</td>
<td>setnbe</td>
<td>D &lt;– ~CF &amp; ~ZF</td>
<td>无符号&gt; (above)</td>
</tr>
<tr>
<td>setae D</td>
<td>setnb</td>
<td>D &lt;– ~CF</td>
<td>无符号&gt;=</td>
</tr>
<tr>
<td>setb D</td>
<td>setnae</td>
<td>D &lt;– CF</td>
<td>无符号&lt; (below)</td>
</tr>
<tr>
<td>setbe D</td>
<td>setna</td>
<td>D &lt;– CF &#124; ZF</td>
<td>无符号&lt;=</td>
</tr>
</tbody></table>
<p>下面是一个例子：<br>设C函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">compare:</span>                        # x <span class="keyword">in</span> %rdi, y <span class="keyword">in</span> %rsi</span><br><span class="line">    cmpq %rsi, %rdi             # compute x - y</span><br><span class="line">    <span class="keyword">setg</span> %al                    # 大于则设置为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line">    movzbl %al, %eax            # 这项操作是使 %eax(<span class="keyword">and</span> %rax) 上其他位的数据全部清空为<span class="number">0</span>，保证返回数据只为%al上的数据</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>等讲了再补</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>未完待续……</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/sakayumerandebu/">【GUMI】逆夢ランデヴー【なつめ千秋】</a></div><div class="item" id="next"></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="RinChanNOWWW/blog-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
