---
title: 6.S081 笔记
date: 2021-11-16 15:24:10
tags:
	- 操作系统
    - C
    - 公开课
categories:
    - 课程学习
---

记录一下学习 MIT 6.S081 与 xv6 book 时遇到的一些问题。

## LEC 1： Introduction

1. 为什么系统调用 `exec` 不直接和 `fork` 做成一块。因为要考虑到管道这种操作的情况，管道需要把前一个程序的标准输出定向到后一个程序的标准输入（使用 close、dup 等操作），由于子进程的文件描述符表和父进程独立，这样先 `fork` 再在子进程中 `exec` 就可以直接不用管后续了。如果做成了 `forkexec` 这种，如果遇到执行失败返回了原本的程序，需要再恢复文件描述符的对应，这样的操作比较繁琐，可扩展性差。

## LEC 4: Page Table

1. 在 RISC-V 中内存管理单元（MMU）并不会保存完整的页表，它会通过寄存器 SATP 找到当前运行的进程的页表，SATP 中存放的是页表在内存中的地址（实际物理地址），只有 SATP 设置了 RISC-V CPU 才会启用 MMU。当不同进程进行切换时，也会更新 SATP。
2. 三级页表中的 PPN 都是实际的物理地址。

3. 为什么硬件（RISC-V）实现了 MMU 的功能，我们还是要在内核代码中实现 walk 这样对虚拟内存翻译的功能？我的理解是，硬件自己实现的 MMU 可以帮助硬件在执行机器代码时可以通过 xv6 写入的页表进行映射，比如 C 语言代码编写的一些非系统调用的操作，比如 C 语言代码中的直接通过某地址访问内存，这个就是虚拟地址，而且就可以靠硬件自己的 MMU 了。而实现 walk 是因为内核需要实现页表的可编程，可以直接通过访问物理内存来实现一些操作（比如一些系统调用），比如直接从指定物理地址提取数据或向指定物理地址写入数据，要不然只能通过机器指令（汇编）获取物理内存中的内容。而且后续课程会提到的 Page Fault 等操作也需要靠这样可编程的页表来操作。另外值得提的一点是，内核在初始化时会将自己的页表构造为和物理地址一对一的映射（direct-mapping），所以内核程序执行时访问的内存地址就是实际的物理地址。

